(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{447:function(t,a,r){"use strict";r.r(a);var e=r(4),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"设计思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[t._v("#")]),t._v(" 设计思想")]),t._v(" "),a("h4",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),a("p",[t._v("组件初始化\t->\trender 方法 \t-> \t生成虚拟DOM \t-> \tReact.DOM.render 方法 \t-> \t真实DOM")]),t._v(" "),a("p",[t._v("组件更新 -> render 方法\t->\t生成新的虚拟DOM\t->\tdiff算法\t->\t定位出两次虚拟DOM的差异")]),t._v(" "),a("h4",{attrs:{id:"组件设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件设计"}},[t._v("#")]),t._v(" 组件设计")]),t._v(" "),a("p",[t._v("既是“封闭”的，也是“开放”的")]),t._v(" "),a("p",[t._v("所谓“封闭”，主要是针对“渲染工作流”（指从组件数据改变到组件实际更新发生的过程）来说的。在组件自身的渲染工作流中，每个组件都只处理它内部的渲染逻辑。在没有数据流交互的情况下，组件与组件之间可以做到“各自为政”。")]),t._v(" "),a("p",[t._v("而所谓“开放”，则是针对组件间通信来说的。React 允许开发者基于“单向数据流”的原则完成组件间的通信。而组件之间的通信又将改变通信双方/某一方内部的数据，进而对渲染结果构成影响。所以说在数据这个“红娘”的牵线搭桥之下，组件之间又是彼此开放的，是可以相互影响的。")]),t._v(" "),a("p",[t._v("这一“开放”与“封闭”兼具的特性，使得 React 组件既专注又灵活，具备高度的可重用性和可维护性。")])])}),[],!1,null,null,null);a.default=s.exports}}]);